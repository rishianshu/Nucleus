// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"bytes"
	"fmt"
	"io"
	"strconv"
	"time"

	"github.com/nucleus/metadata-api/internal/database"
)

type CatalogColumn struct {
	ID       string  `json:"id"`
	Name     string  `json:"name"`
	TableID  *string `json:"tableId,omitempty"`
	DataType *string `json:"dataType,omitempty"`
	Nullable *bool   `json:"nullable,omitempty"`
}

type CatalogDataset struct {
	ID                string                          `json:"id"`
	UpstreamID        *string                         `json:"upstreamId,omitempty"`
	DisplayName       string                          `json:"displayName"`
	Description       *string                         `json:"description,omitempty"`
	Source            *string                         `json:"source,omitempty"`
	ProjectIds        []string                        `json:"projectIds,omitempty"`
	Labels            []string                        `json:"labels,omitempty"`
	Schema            *string                         `json:"schema,omitempty"`
	Entity            *string                         `json:"entity,omitempty"`
	CollectedAt       *time.Time                      `json:"collectedAt,omitempty"`
	SourceEndpointID  *string                         `json:"sourceEndpointId,omitempty"`
	SourceEndpoint    *database.MetadataEndpoint      `json:"sourceEndpoint,omitempty"`
	Profile           *CatalogDatasetProfile          `json:"profile,omitempty"`
	SampleRows        []map[string]any                `json:"sampleRows,omitempty"`
	Statistics        map[string]any                  `json:"statistics,omitempty"`
	Fields            []CatalogDatasetField           `json:"fields"`
	LastCollectionRun *database.MetadataCollectionRun `json:"lastCollectionRun,omitempty"`
	IngestionConfig   *database.IngestionUnitConfig   `json:"ingestionConfig,omitempty"`
	Tables            []CatalogTable                  `json:"tables"`
}

type CatalogDatasetConnection struct {
	Nodes      []CatalogDataset     `json:"nodes"`
	Edges      []CatalogDatasetEdge `json:"edges"`
	PageInfo   *PageInfo            `json:"pageInfo"`
	TotalCount int                  `json:"totalCount"`
}

type CatalogDatasetEdge struct {
	Cursor string          `json:"cursor"`
	Node   *CatalogDataset `json:"node"`
}

type CatalogDatasetField struct {
	Name        string  `json:"name"`
	Type        string  `json:"type"`
	Description *string `json:"description,omitempty"`
}

type CatalogDatasetPreview struct {
	SampledAt time.Time        `json:"sampledAt"`
	Rows      []map[string]any `json:"rows"`
}

type CatalogDatasetProfile struct {
	RecordCount    *int           `json:"recordCount,omitempty"`
	SampleSize     *int           `json:"sampleSize,omitempty"`
	LastProfiledAt *time.Time     `json:"lastProfiledAt,omitempty"`
	Raw            map[string]any `json:"raw,omitempty"`
}

type CatalogForeignKey struct {
	Name        *string         `json:"name,omitempty"`
	FromTable   *CatalogTable   `json:"fromTable"`
	FromColumns []CatalogColumn `json:"fromColumns"`
	ToTable     *CatalogTable   `json:"toTable"`
	ToColumns   []CatalogColumn `json:"toColumns"`
	OnDelete    *string         `json:"onDelete,omitempty"`
	OnUpdate    *string         `json:"onUpdate,omitempty"`
}

type CatalogTable struct {
	ID                  string              `json:"id"`
	Name                string              `json:"name"`
	Schema              *string             `json:"schema,omitempty"`
	Columns             []CatalogColumn     `json:"columns"`
	PrimaryKeyColumns   []CatalogColumn     `json:"primaryKeyColumns"`
	InboundForeignKeys  []CatalogForeignKey `json:"inboundForeignKeys"`
	OutboundForeignKeys []CatalogForeignKey `json:"outboundForeignKeys"`
}

type CollectionCreateInput struct {
	EndpointID       string  `json:"endpointId"`
	ScheduleCron     *string `json:"scheduleCron,omitempty"`
	ScheduleTimezone *string `json:"scheduleTimezone,omitempty"`
	IsEnabled        *bool   `json:"isEnabled,omitempty"`
}

type CollectionUpdateInput struct {
	ScheduleCron     *string `json:"scheduleCron,omitempty"`
	ScheduleTimezone *string `json:"scheduleTimezone,omitempty"`
	IsEnabled        *bool   `json:"isEnabled,omitempty"`
}

type Diagnostic struct {
	Level   string  `json:"level"`
	Code    string  `json:"code"`
	Message string  `json:"message"`
	Hint    *string `json:"hint,omitempty"`
	Field   *string `json:"field,omitempty"`
}

type EndpointInput struct {
	ProjectSlug  *string        `json:"projectSlug,omitempty"`
	SourceID     *string        `json:"sourceId,omitempty"`
	Name         string         `json:"name"`
	Description  *string        `json:"description,omitempty"`
	Verb         string         `json:"verb"`
	URL          *string        `json:"url,omitempty"`
	AuthPolicy   *string        `json:"authPolicy,omitempty"`
	Domain       *string        `json:"domain,omitempty"`
	Labels       []string       `json:"labels,omitempty"`
	Config       map[string]any `json:"config,omitempty"`
	Capabilities []string       `json:"capabilities,omitempty"`
}

type EndpointPatch struct {
	Name         *string        `json:"name,omitempty"`
	Description  *string        `json:"description,omitempty"`
	Verb         *string        `json:"verb,omitempty"`
	URL          *string        `json:"url,omitempty"`
	AuthPolicy   *string        `json:"authPolicy,omitempty"`
	Domain       *string        `json:"domain,omitempty"`
	Labels       []string       `json:"labels,omitempty"`
	Config       map[string]any `json:"config,omitempty"`
	Capabilities []string       `json:"capabilities,omitempty"`
}

type GraphEdgeFilter struct {
	EdgeTypes      []string `json:"edgeTypes,omitempty"`
	SourceEntityID *string  `json:"sourceEntityId,omitempty"`
	TargetEntityID *string  `json:"targetEntityId,omitempty"`
	Limit          *int     `json:"limit,omitempty"`
}

type GraphNodeFilter struct {
	EntityTypes []string `json:"entityTypes,omitempty"`
	Search      *string  `json:"search,omitempty"`
	Limit       *int     `json:"limit,omitempty"`
}

type GraphScopeInput struct {
	OrgID     *string `json:"orgId,omitempty"`
	DomainID  *string `json:"domainId,omitempty"`
	ProjectID *string `json:"projectId,omitempty"`
	TeamID    *string `json:"teamId,omitempty"`
}

type Health struct {
	Status  string `json:"status"`
	Version string `json:"version"`
}

type IngestionActionResult struct {
	Ok      bool                     `json:"ok"`
	RunID   *string                  `json:"runId,omitempty"`
	State   *database.IngestionState `json:"state,omitempty"`
	Message *string                  `json:"message,omitempty"`
}

type IngestionSink struct {
	ID                 string   `json:"id"`
	SupportedCdmModels []string `json:"supportedCdmModels,omitempty"`
}

type IngestionStatus struct {
	EndpointID string                  `json:"endpointId"`
	UnitID     string                  `json:"unitId"`
	SinkID     string                  `json:"sinkId"`
	State      database.IngestionState `json:"state"`
	LastRunID  *string                 `json:"lastRunId,omitempty"`
	LastRunAt  *time.Time              `json:"lastRunAt,omitempty"`
	LastError  *string                 `json:"lastError,omitempty"`
	Stats      map[string]any          `json:"stats,omitempty"`
	Checkpoint map[string]any          `json:"checkpoint,omitempty"`
}

type IngestionUnit struct {
	EndpointID                     string         `json:"endpointId"`
	UnitID                         string         `json:"unitId"`
	DatasetID                      *string        `json:"datasetId,omitempty"`
	Kind                           string         `json:"kind"`
	DisplayName                    string         `json:"displayName"`
	Stats                          map[string]any `json:"stats,omitempty"`
	DriverID                       string         `json:"driverId"`
	SinkID                         string         `json:"sinkId"`
	DefaultMode                    *string        `json:"defaultMode,omitempty"`
	SupportedModes                 []string       `json:"supportedModes,omitempty"`
	DefaultPolicy                  map[string]any `json:"defaultPolicy,omitempty"`
	DefaultScheduleKind            *string        `json:"defaultScheduleKind,omitempty"`
	DefaultScheduleIntervalMinutes *int           `json:"defaultScheduleIntervalMinutes,omitempty"`
	CdmModelID                     *string        `json:"cdmModelId,omitempty"`
}

type IngestionUnitConfigInput struct {
	EndpointID              string         `json:"endpointId"`
	UnitID                  string         `json:"unitId"`
	Enabled                 *bool          `json:"enabled,omitempty"`
	RunMode                 *string        `json:"runMode,omitempty"`
	Mode                    *string        `json:"mode,omitempty"`
	SinkID                  *string        `json:"sinkId,omitempty"`
	SinkEndpointID          *string        `json:"sinkEndpointId,omitempty"`
	ScheduleKind            *string        `json:"scheduleKind,omitempty"`
	ScheduleIntervalMinutes *int           `json:"scheduleIntervalMinutes,omitempty"`
	Policy                  map[string]any `json:"policy,omitempty"`
}

type KbEdgeConnection struct {
	Edges      []KbEdgeEdge `json:"edges"`
	PageInfo   *PageInfo    `json:"pageInfo"`
	TotalCount int          `json:"totalCount"`
}

type KbEdgeEdge struct {
	Cursor string              `json:"cursor"`
	Node   *database.GraphEdge `json:"node"`
}

type KbEdgeType struct {
	Value       string   `json:"value"`
	Label       string   `json:"label"`
	Description *string  `json:"description,omitempty"`
	Synonyms    []string `json:"synonyms"`
	Icon        *string  `json:"icon,omitempty"`
	Actions     []string `json:"actions"`
}

type KbFacetValue struct {
	Value string `json:"value"`
	Label string `json:"label"`
	Count int    `json:"count"`
}

type KbFacets struct {
	NodeTypes []KbFacetValue `json:"nodeTypes"`
	EdgeTypes []KbFacetValue `json:"edgeTypes"`
	Projects  []KbFacetValue `json:"projects"`
	Domains   []KbFacetValue `json:"domains"`
	Teams     []KbFacetValue `json:"teams"`
}

type KbMeta struct {
	Version   string       `json:"version"`
	NodeTypes []KbNodeType `json:"nodeTypes"`
	EdgeTypes []KbEdgeType `json:"edgeTypes"`
}

type KbNodeConnection struct {
	Edges      []KbNodeEdge `json:"edges"`
	PageInfo   *PageInfo    `json:"pageInfo"`
	TotalCount int          `json:"totalCount"`
}

type KbNodeEdge struct {
	Cursor string              `json:"cursor"`
	Node   *database.GraphNode `json:"node"`
}

type KbNodeType struct {
	Value         string   `json:"value"`
	Label         string   `json:"label"`
	Description   *string  `json:"description,omitempty"`
	Synonyms      []string `json:"synonyms"`
	Icon          *string  `json:"icon,omitempty"`
	FieldsDisplay []string `json:"fieldsDisplay"`
	Actions       []string `json:"actions"`
}

type KbScene struct {
	Nodes   []database.GraphNode `json:"nodes"`
	Edges   []database.GraphEdge `json:"edges"`
	Summary *KbSceneSummary      `json:"summary"`
}

type KbSceneSummary struct {
	NodeCount int  `json:"nodeCount"`
	EdgeCount int  `json:"edgeCount"`
	Truncated bool `json:"truncated"`
}

type MetadataCollectionRequestInput struct {
	EndpointID string   `json:"endpointId"`
	Schemas    []string `json:"schemas,omitempty"`
}

type MetadataCollectionRunFilter struct {
	EndpointID   *string                   `json:"endpointId,omitempty"`
	CollectionID *string                   `json:"collectionId,omitempty"`
	Status       *MetadataCollectionStatus `json:"status,omitempty"`
	From         *time.Time                `json:"from,omitempty"`
	To           *time.Time                `json:"to,omitempty"`
}

type MetadataDomain struct {
	Key         string  `json:"key"`
	Title       string  `json:"title"`
	Description *string `json:"description,omitempty"`
	ItemCount   int     `json:"itemCount"`
}

type MetadataEndpointCapability struct {
	Key         string  `json:"key"`
	Label       string  `json:"label"`
	Description *string `json:"description,omitempty"`
}

type MetadataEndpointConnection struct {
	URLTemplate *string `json:"urlTemplate,omitempty"`
	DefaultVerb *string `json:"defaultVerb,omitempty"`
}

type MetadataEndpointField struct {
	Key          string                                `json:"key"`
	Label        string                                `json:"label"`
	Required     bool                                  `json:"required"`
	ValueType    MetadataEndpointFieldValueType        `json:"valueType"`
	Semantic     *MetadataEndpointFieldSemantic        `json:"semantic,omitempty"`
	Description  *string                               `json:"description,omitempty"`
	Placeholder  *string                               `json:"placeholder,omitempty"`
	HelpText     *string                               `json:"helpText,omitempty"`
	Options      []MetadataEndpointRequirementOption   `json:"options,omitempty"`
	Regex        *string                               `json:"regex,omitempty"`
	Min          *int                                  `json:"min,omitempty"`
	Max          *int                                  `json:"max,omitempty"`
	DefaultValue *string                               `json:"defaultValue,omitempty"`
	Advanced     *bool                                 `json:"advanced,omitempty"`
	Sensitive    *bool                                 `json:"sensitive,omitempty"`
	DependsOn    *string                               `json:"dependsOn,omitempty"`
	DependsValue *string                               `json:"dependsValue,omitempty"`
	VisibleWhen  []MetadataEndpointFieldVisibilityRule `json:"visibleWhen,omitempty"`
}

type MetadataEndpointFieldVisibilityRule struct {
	Field  string   `json:"field"`
	Values []string `json:"values"`
}

type MetadataEndpointInput struct {
	ID          *string        `json:"id,omitempty"`
	SourceID    *string        `json:"sourceId,omitempty"`
	ProjectID   *string        `json:"projectId,omitempty"`
	Name        string         `json:"name"`
	Description *string        `json:"description,omitempty"`
	Verb        *string        `json:"verb,omitempty"`
	URL         *string        `json:"url,omitempty"`
	AuthPolicy  *string        `json:"authPolicy,omitempty"`
	Domain      *string        `json:"domain,omitempty"`
	Labels      []string       `json:"labels,omitempty"`
	Config      map[string]any `json:"config,omitempty"`
}

type MetadataEndpointProbingMethod struct {
	Key                 string   `json:"key"`
	Label               string   `json:"label"`
	Strategy            string   `json:"strategy"`
	Statement           *string  `json:"statement,omitempty"`
	Description         *string  `json:"description,omitempty"`
	Requires            []string `json:"requires,omitempty"`
	ReturnsVersion      *bool    `json:"returnsVersion,omitempty"`
	ReturnsCapabilities []string `json:"returnsCapabilities,omitempty"`
}

type MetadataEndpointProbingPlan struct {
	Methods         []MetadataEndpointProbingMethod `json:"methods"`
	FallbackMessage *string                         `json:"fallbackMessage,omitempty"`
}

type MetadataEndpointRequirementOption struct {
	Label       string  `json:"label"`
	Value       string  `json:"value"`
	Description *string `json:"description,omitempty"`
}

type MetadataEndpointTemplate struct {
	ID                string                       `json:"id"`
	Family            MetadataEndpointFamily       `json:"family"`
	Title             string                       `json:"title"`
	Vendor            string                       `json:"vendor"`
	Description       *string                      `json:"description,omitempty"`
	Domain            *string                      `json:"domain,omitempty"`
	Categories        []string                     `json:"categories"`
	Protocols         []string                     `json:"protocols"`
	Versions          []string                     `json:"versions"`
	DefaultPort       *int                         `json:"defaultPort,omitempty"`
	Driver            *string                      `json:"driver,omitempty"`
	DocsURL           *string                      `json:"docsUrl,omitempty"`
	AgentPrompt       *string                      `json:"agentPrompt,omitempty"`
	DefaultLabels     []string                     `json:"defaultLabels,omitempty"`
	Fields            []MetadataEndpointField      `json:"fields"`
	Capabilities      []MetadataEndpointCapability `json:"capabilities"`
	SampleConfig      map[string]any               `json:"sampleConfig,omitempty"`
	Connection        *MetadataEndpointConnection  `json:"connection,omitempty"`
	DescriptorVersion *string                      `json:"descriptorVersion,omitempty"`
	MinVersion        *string                      `json:"minVersion,omitempty"`
	MaxVersion        *string                      `json:"maxVersion,omitempty"`
	Probing           *MetadataEndpointProbingPlan `json:"probing,omitempty"`
	Extras            map[string]any               `json:"extras,omitempty"`
}

type MetadataEndpointTestResult struct {
	Success         bool           `json:"success"`
	Message         *string        `json:"message,omitempty"`
	DetectedVersion *string        `json:"detectedVersion,omitempty"`
	Capabilities    []string       `json:"capabilities,omitempty"`
	Details         map[string]any `json:"details,omitempty"`
}

type MetadataRecordInput struct {
	ID        *string        `json:"id,omitempty"`
	ProjectID string         `json:"projectId"`
	Domain    string         `json:"domain"`
	Labels    []string       `json:"labels,omitempty"`
	Payload   map[string]any `json:"payload"`
}

type Mutation struct {
}

type OneDriveAuthResult struct {
	Ok         bool    `json:"ok"`
	EndpointID *string `json:"endpointId,omitempty"`
}

type PageInfo struct {
	HasNextPage     bool    `json:"hasNextPage"`
	HasPreviousPage bool    `json:"hasPreviousPage"`
	StartCursor     *string `json:"startCursor,omitempty"`
	EndCursor       *string `json:"endCursor,omitempty"`
}

type Query struct {
}

type TestEndpointInput struct {
	TemplateID   string         `json:"templateId"`
	Type         string         `json:"type"`
	Connection   map[string]any `json:"connection"`
	Capabilities []string       `json:"capabilities,omitempty"`
}

type TestResult struct {
	Ok          bool         `json:"ok"`
	Diagnostics []Diagnostic `json:"diagnostics"`
}

type GraphEdgeDirection string

const (
	GraphEdgeDirectionOutbound GraphEdgeDirection = "OUTBOUND"
	GraphEdgeDirectionInbound  GraphEdgeDirection = "INBOUND"
	GraphEdgeDirectionBoth     GraphEdgeDirection = "BOTH"
)

var AllGraphEdgeDirection = []GraphEdgeDirection{
	GraphEdgeDirectionOutbound,
	GraphEdgeDirectionInbound,
	GraphEdgeDirectionBoth,
}

func (e GraphEdgeDirection) IsValid() bool {
	switch e {
	case GraphEdgeDirectionOutbound, GraphEdgeDirectionInbound, GraphEdgeDirectionBoth:
		return true
	}
	return false
}

func (e GraphEdgeDirection) String() string {
	return string(e)
}

func (e *GraphEdgeDirection) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GraphEdgeDirection(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GraphEdgeDirection", str)
	}
	return nil
}

func (e GraphEdgeDirection) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *GraphEdgeDirection) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e GraphEdgeDirection) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type MetadataCollectionStatus string

const (
	MetadataCollectionStatusQueued    MetadataCollectionStatus = "QUEUED"
	MetadataCollectionStatusRunning   MetadataCollectionStatus = "RUNNING"
	MetadataCollectionStatusSucceeded MetadataCollectionStatus = "SUCCEEDED"
	MetadataCollectionStatusFailed    MetadataCollectionStatus = "FAILED"
	MetadataCollectionStatusSkipped   MetadataCollectionStatus = "SKIPPED"
)

var AllMetadataCollectionStatus = []MetadataCollectionStatus{
	MetadataCollectionStatusQueued,
	MetadataCollectionStatusRunning,
	MetadataCollectionStatusSucceeded,
	MetadataCollectionStatusFailed,
	MetadataCollectionStatusSkipped,
}

func (e MetadataCollectionStatus) IsValid() bool {
	switch e {
	case MetadataCollectionStatusQueued, MetadataCollectionStatusRunning, MetadataCollectionStatusSucceeded, MetadataCollectionStatusFailed, MetadataCollectionStatusSkipped:
		return true
	}
	return false
}

func (e MetadataCollectionStatus) String() string {
	return string(e)
}

func (e *MetadataCollectionStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MetadataCollectionStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MetadataCollectionStatus", str)
	}
	return nil
}

func (e MetadataCollectionStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *MetadataCollectionStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e MetadataCollectionStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type MetadataEndpointFamily string

const (
	MetadataEndpointFamilyJdbc   MetadataEndpointFamily = "JDBC"
	MetadataEndpointFamilyHTTP   MetadataEndpointFamily = "HTTP"
	MetadataEndpointFamilyStream MetadataEndpointFamily = "STREAM"
)

var AllMetadataEndpointFamily = []MetadataEndpointFamily{
	MetadataEndpointFamilyJdbc,
	MetadataEndpointFamilyHTTP,
	MetadataEndpointFamilyStream,
}

func (e MetadataEndpointFamily) IsValid() bool {
	switch e {
	case MetadataEndpointFamilyJdbc, MetadataEndpointFamilyHTTP, MetadataEndpointFamilyStream:
		return true
	}
	return false
}

func (e MetadataEndpointFamily) String() string {
	return string(e)
}

func (e *MetadataEndpointFamily) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MetadataEndpointFamily(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MetadataEndpointFamily", str)
	}
	return nil
}

func (e MetadataEndpointFamily) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *MetadataEndpointFamily) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e MetadataEndpointFamily) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type MetadataEndpointFieldSemantic string

const (
	MetadataEndpointFieldSemanticHost        MetadataEndpointFieldSemantic = "HOST"
	MetadataEndpointFieldSemanticPort        MetadataEndpointFieldSemantic = "PORT"
	MetadataEndpointFieldSemanticDatabase    MetadataEndpointFieldSemantic = "DATABASE"
	MetadataEndpointFieldSemanticUsername    MetadataEndpointFieldSemantic = "USERNAME"
	MetadataEndpointFieldSemanticPassword    MetadataEndpointFieldSemantic = "PASSWORD"
	MetadataEndpointFieldSemanticAPIToken    MetadataEndpointFieldSemantic = "API_TOKEN"
	MetadataEndpointFieldSemanticProject     MetadataEndpointFieldSemantic = "PROJECT"
	MetadataEndpointFieldSemanticSchema      MetadataEndpointFieldSemantic = "SCHEMA"
	MetadataEndpointFieldSemanticTable       MetadataEndpointFieldSemantic = "TABLE"
	MetadataEndpointFieldSemanticWarehouse   MetadataEndpointFieldSemantic = "WAREHOUSE"
	MetadataEndpointFieldSemanticRole        MetadataEndpointFieldSemantic = "ROLE"
	MetadataEndpointFieldSemanticEnvironment MetadataEndpointFieldSemantic = "ENVIRONMENT"
	MetadataEndpointFieldSemanticCluster     MetadataEndpointFieldSemantic = "CLUSTER"
	MetadataEndpointFieldSemanticTopic       MetadataEndpointFieldSemantic = "TOPIC"
	MetadataEndpointFieldSemanticGeneric     MetadataEndpointFieldSemantic = "GENERIC"
	MetadataEndpointFieldSemanticFilePath    MetadataEndpointFieldSemantic = "FILE_PATH"
)

var AllMetadataEndpointFieldSemantic = []MetadataEndpointFieldSemantic{
	MetadataEndpointFieldSemanticHost,
	MetadataEndpointFieldSemanticPort,
	MetadataEndpointFieldSemanticDatabase,
	MetadataEndpointFieldSemanticUsername,
	MetadataEndpointFieldSemanticPassword,
	MetadataEndpointFieldSemanticAPIToken,
	MetadataEndpointFieldSemanticProject,
	MetadataEndpointFieldSemanticSchema,
	MetadataEndpointFieldSemanticTable,
	MetadataEndpointFieldSemanticWarehouse,
	MetadataEndpointFieldSemanticRole,
	MetadataEndpointFieldSemanticEnvironment,
	MetadataEndpointFieldSemanticCluster,
	MetadataEndpointFieldSemanticTopic,
	MetadataEndpointFieldSemanticGeneric,
	MetadataEndpointFieldSemanticFilePath,
}

func (e MetadataEndpointFieldSemantic) IsValid() bool {
	switch e {
	case MetadataEndpointFieldSemanticHost, MetadataEndpointFieldSemanticPort, MetadataEndpointFieldSemanticDatabase, MetadataEndpointFieldSemanticUsername, MetadataEndpointFieldSemanticPassword, MetadataEndpointFieldSemanticAPIToken, MetadataEndpointFieldSemanticProject, MetadataEndpointFieldSemanticSchema, MetadataEndpointFieldSemanticTable, MetadataEndpointFieldSemanticWarehouse, MetadataEndpointFieldSemanticRole, MetadataEndpointFieldSemanticEnvironment, MetadataEndpointFieldSemanticCluster, MetadataEndpointFieldSemanticTopic, MetadataEndpointFieldSemanticGeneric, MetadataEndpointFieldSemanticFilePath:
		return true
	}
	return false
}

func (e MetadataEndpointFieldSemantic) String() string {
	return string(e)
}

func (e *MetadataEndpointFieldSemantic) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MetadataEndpointFieldSemantic(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MetadataEndpointFieldSemantic", str)
	}
	return nil
}

func (e MetadataEndpointFieldSemantic) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *MetadataEndpointFieldSemantic) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e MetadataEndpointFieldSemantic) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type MetadataEndpointFieldValueType string

const (
	MetadataEndpointFieldValueTypeString   MetadataEndpointFieldValueType = "STRING"
	MetadataEndpointFieldValueTypePassword MetadataEndpointFieldValueType = "PASSWORD"
	MetadataEndpointFieldValueTypeNumber   MetadataEndpointFieldValueType = "NUMBER"
	MetadataEndpointFieldValueTypeBoolean  MetadataEndpointFieldValueType = "BOOLEAN"
	MetadataEndpointFieldValueTypeURL      MetadataEndpointFieldValueType = "URL"
	MetadataEndpointFieldValueTypeHostname MetadataEndpointFieldValueType = "HOSTNAME"
	MetadataEndpointFieldValueTypePort     MetadataEndpointFieldValueType = "PORT"
	MetadataEndpointFieldValueTypeJSON     MetadataEndpointFieldValueType = "JSON"
	MetadataEndpointFieldValueTypeEnum     MetadataEndpointFieldValueType = "ENUM"
	MetadataEndpointFieldValueTypeList     MetadataEndpointFieldValueType = "LIST"
	MetadataEndpointFieldValueTypeText     MetadataEndpointFieldValueType = "TEXT"
)

var AllMetadataEndpointFieldValueType = []MetadataEndpointFieldValueType{
	MetadataEndpointFieldValueTypeString,
	MetadataEndpointFieldValueTypePassword,
	MetadataEndpointFieldValueTypeNumber,
	MetadataEndpointFieldValueTypeBoolean,
	MetadataEndpointFieldValueTypeURL,
	MetadataEndpointFieldValueTypeHostname,
	MetadataEndpointFieldValueTypePort,
	MetadataEndpointFieldValueTypeJSON,
	MetadataEndpointFieldValueTypeEnum,
	MetadataEndpointFieldValueTypeList,
	MetadataEndpointFieldValueTypeText,
}

func (e MetadataEndpointFieldValueType) IsValid() bool {
	switch e {
	case MetadataEndpointFieldValueTypeString, MetadataEndpointFieldValueTypePassword, MetadataEndpointFieldValueTypeNumber, MetadataEndpointFieldValueTypeBoolean, MetadataEndpointFieldValueTypeURL, MetadataEndpointFieldValueTypeHostname, MetadataEndpointFieldValueTypePort, MetadataEndpointFieldValueTypeJSON, MetadataEndpointFieldValueTypeEnum, MetadataEndpointFieldValueTypeList, MetadataEndpointFieldValueTypeText:
		return true
	}
	return false
}

func (e MetadataEndpointFieldValueType) String() string {
	return string(e)
}

func (e *MetadataEndpointFieldValueType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MetadataEndpointFieldValueType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MetadataEndpointFieldValueType", str)
	}
	return nil
}

func (e MetadataEndpointFieldValueType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *MetadataEndpointFieldValueType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e MetadataEndpointFieldValueType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}
