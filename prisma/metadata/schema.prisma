generator metadata_client {
  provider = "prisma-client-js"
  output   = "../../../node_modules/.metadata-client"
}

datasource db {
  provider = "postgresql"
  url      = env("METADATA_DATABASE_URL")
}

model MetadataProject {
  id          String            @id @default(uuid())
  slug        String            @unique
  displayName String
  description String?
  labels      String[]          @default([])
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt
  records     MetadataRecord[]
  endpoints   MetadataEndpoint[]
}

model MetadataRecord {
  id        String          @default(uuid())
  projectId String
  project   MetadataProject @relation(fields: [projectId], references: [id], onDelete: Cascade)
  domain    String
  labels    String[]        @default([])
  searchText String         @default("")
  payload   Json
  createdAt DateTime        @default(now())
  updatedAt DateTime        @updatedAt

  @@id([domain, id])
  @@index([projectId, domain])
}

model MetadataEndpoint {
  id          String            @id @default(uuid())
  projectId   String?
  project     MetadataProject?  @relation(fields: [projectId], references: [id], onDelete: Cascade)
  sourceId    String            @unique
  name        String
  description String?
  verb        String
  url         String
  authPolicy  String?
  domain      String?
  labels      String[]          @default([])
  config      Json?
  detectedVersion String?
  versionHint String?
  capabilities String[] @default([])
  collections MetadataCollection[]
  runs        MetadataCollectionRun[]
  ingestionConfigs IngestionUnitConfig[]
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt
  deletedAt   DateTime?
  deletionReason String?

  @@index([projectId])
}

model MetadataCollection {
  id                 String               @id @default(uuid())
  endpointId         String
  endpoint           MetadataEndpoint     @relation(fields: [endpointId], references: [id], onDelete: Cascade)
  scheduleCron       String?
  scheduleTimezone   String               @default("UTC")
  isEnabled          Boolean              @default(true)
  temporalScheduleId String?
  createdAt          DateTime             @default(now())
  updatedAt          DateTime             @updatedAt

  runs               MetadataCollectionRun[]

  @@index([endpointId])
}

model MetadataDomain {
  id          String   @id @default(uuid())
  key         String   @unique
  title       String
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model MetadataCollectionRun {
  id            String                     @id @default(uuid())
  collectionId  String?
  collection    MetadataCollection?        @relation(fields: [collectionId], references: [id], onDelete: SetNull)
  endpointId    String
  endpoint      MetadataEndpoint           @relation(fields: [endpointId], references: [id], onDelete: Cascade)
  status        MetadataCollectionStatus   @default(QUEUED)
  requestedBy   String?
  requestedAt   DateTime                   @default(now())
  startedAt     DateTime?
  completedAt   DateTime?
  workflowId    String?
  temporalRunId String?
  error         String?
  filters       Json?
  createdAt     DateTime                   @default(now())
  updatedAt     DateTime                   @updatedAt

  @@index([collectionId])
  @@index([endpointId])
}

enum MetadataCollectionStatus {
  QUEUED
  RUNNING
  SUCCEEDED
  FAILED
  SKIPPED
}

model MetadataEndpointTemplate {
  id        String   @id
  family    String
  title     String
  vendor    String
  descriptor Json
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model IngestionUnitState {
  endpointId String
  unitId     String
  sinkId     String
  state      String          @default("IDLE")
  checkpoint Json?
  lastRunId  String?
  lastRunAt  DateTime?
  lastError  String?
  stats      Json?
  createdAt  DateTime        @default(now())
  updatedAt  DateTime        @updatedAt

  @@id([endpointId, unitId])
  @@index([endpointId])
}

model IngestionUnitConfig {
  id                      String           @id @default(uuid())
  endpointId              String
  endpoint                MetadataEndpoint @relation(fields: [endpointId], references: [id], onDelete: Cascade)
  datasetId               String
  unitId                  String
  enabled                 Boolean          @default(false)
  mode                    String           @default("FULL")
  sinkId                  String           @default("kb")
  scheduleKind            String           @default("MANUAL")
  scheduleIntervalMinutes Int?
  policy                  Json?
  createdAt               DateTime         @default(now())
  updatedAt               DateTime         @updatedAt

  @@unique([endpointId, unitId])
  @@index([datasetId])
}

model GraphNode {
  id              String   @id @default(uuid())
  tenantId        String
  projectId       String?
  entityType      String
  displayName     String
  canonicalPath   String?
  sourceSystem    String?
  specRef         String?
  properties      Json     @default("{}")
  version         Int      @default(1)
  scopeOrgId      String
  scopeDomainId   String?
  scopeProjectId  String?
  scopeTeamId     String?
  originEndpointId String?
  originVendor    String?
  logicalKey      String   @unique
  externalId      Json?
  phase           String?
  provenance      Json?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  sourceEdges GraphEdge[] @relation("sourceEdges")
  targetEdges GraphEdge[] @relation("targetEdges")

  @@index([scopeOrgId, entityType])
  @@index([scopeOrgId, scopeProjectId])
}

model GraphEdge {
  id               String   @id @default(uuid())
  tenantId         String
  projectId        String?
  edgeType         String
  sourceNodeId     String
  targetNodeId     String
  sourceNode       GraphNode @relation("sourceEdges", fields: [sourceNodeId], references: [id], onDelete: Cascade)
  targetNode       GraphNode @relation("targetEdges", fields: [targetNodeId], references: [id], onDelete: Cascade)
  sourceLogicalKey String
  targetLogicalKey String
  scopeOrgId       String
  scopeDomainId    String?
  scopeProjectId   String?
  scopeTeamId      String?
  originEndpointId String?
  originVendor     String?
  logicalKey       String   @unique
  confidence       Float?
  specRef          String?
  metadata         Json     @default("{}")
  externalId       Json?
  phase            String?
  provenance       Json?
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  @@index([scopeOrgId, edgeType])
  @@index([sourceLogicalKey])
  @@index([targetLogicalKey])
}
