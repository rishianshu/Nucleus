- Extend the existing `vector_index_entries` table to carry doc_id, entity_kind, source_family, source_url/external_id, observed_at, content_text, raw_payload, and source_pointer (doc_id + profile_id unique), keeping existing node_id/profile_id/chunk_id uniqueness so graph profiles remain unchanged.
- Canonical code profile `code.github.v1` normalizes projectKey to lower-case `{owner}/{repo}`, entityKind=`code.file_chunk`, profileKind=`code`, sourceFamily=`github`, docId=`code:github:{tenantId}:{projectKey}:{path}:{sha}:{chunkIndex}`. Content comes from `payload.text` truncated to 20k chars; attributes capture path/sha/chunkIndex/language/truncated flag. Missing tenantId/projectKey/profileKind fail closed with E_MISSING_CANONICAL_KEYS. Profile is also seeded into `vector_index_profiles` with text_source field hints.
- Deterministic embeddings use a fake provider that hashes text to a one-hot 1536-dim vector (no external calls) for tests and default offline runs.
- Index runs read MinIO-style JSONL.GZ envelopes from a dataset prefix (supports `minio://bucket/prefix`) via filesystem, streaming/decompressing lines; optional `ingestionRunId` filters to `run=<id>` segments (basePrefix defaults to `sink`). Errors classify as E_SOURCE_READ_FAILED, E_INVALID_RECORD, E_MISSING_CANONICAL_KEYS, E_EMBEDDING_FAILED, or E_VECTOR_DB_FAILED. Oversized text is truncated; malformed/missing-key records are skipped and surfaced as errors, with run status set to SUCCEEDED_WITH_ERRORS when any non-fatal errors occur.
- Staging replay now surfaces `vectorPayload` and `rawPayload` to IndexArtifact; normalization unwraps nested payloads so VectorProfile normalizers see original records, and KV checkpoint client defaults to VECTOR_GRPC_ADDR/9099 (falling back from KV/UCL) to avoid checkpoint timeouts when store-core runs on 9099.
